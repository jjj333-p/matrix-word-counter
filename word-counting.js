𝓲𝓶𝓹𝓸𝓻𝓽 𝓯𝓼 𝓯𝓻𝓸𝓶 "𝓷𝓸𝓭𝓮:𝓯𝓼";
𝓲𝓶𝓹𝓸𝓻𝓽 { 𝓜𝓸𝓭𝓾𝓵𝓮 } 𝓯𝓻𝓸𝓶 "𝓷𝓸𝓭𝓮:𝓶𝓸𝓭𝓾𝓵𝓮";

𝓬𝓵𝓪𝓼𝓼 𝓦𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽 {
	𝓬𝓸𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓸𝓻() {
		𝓬𝓸𝓷𝓼𝓽 𝓪 = 𝓯𝓼.𝓻𝓮𝓪𝓭𝓭𝓲𝓻𝓢𝔂𝓷𝓬("./𝓭𝓫");

		//𝓶𝓪𝓴𝓮 𝓼𝓾𝓻𝓮 𝓭𝓲𝓻 𝓮𝔁𝓲𝓼𝓽𝓼
		𝓲𝓯 (!𝓪.𝓼𝓸𝓶𝓮((𝓫) =&gt; 𝓫 === "𝓬𝓸𝓾𝓷𝓽")) {
			//𝓲𝓯 𝓷𝓸𝓽, 𝓶𝓪𝓴𝓮 𝓽𝓱𝓮 𝓯𝓸𝓵𝓭𝓮𝓻 𝓯𝓸𝓻 𝓲𝓽
			𝓯𝓼.𝓶𝓴𝓭𝓲𝓻𝓢𝔂𝓷𝓬("./𝓭𝓫/𝓬𝓸𝓾𝓷𝓽");
		}
		𝓬𝓸𝓷𝓼𝓽 𝓻𝓸𝓸𝓶𝓙𝓢𝓞𝓝𝓵𝓲𝓼𝓽 = 𝓯𝓼.𝓻𝓮𝓪𝓭𝓭𝓲𝓻𝓢𝔂𝓷𝓬("./𝓭𝓫/𝓬𝓸𝓾𝓷𝓽");

		//𝓶𝓪𝓹 𝓽𝓸 𝓼𝓽𝓸𝓻𝓮 𝓮𝓿𝓮𝓻𝔂𝓽𝓱𝓲𝓷𝓰 𝓲𝓷
		𝓽𝓱𝓲𝓼.𝓹𝓮𝓻𝓡𝓸𝓸𝓶 = 𝓷𝓮𝔀 𝓜𝓪𝓹();
		𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮𝓟𝓻𝓸𝓶𝓲𝓼𝓮 = 𝓷𝓮𝔀 𝓜𝓪𝓹();
		𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮𝓠𝓾𝓮𝓾𝓮𝓭 = 𝓷𝓮𝔀 𝓜𝓪𝓹();
		𝓽𝓱𝓲𝓼.𝓼𝓽𝓪𝓽𝓼𝓢𝓽𝓻𝓲𝓷𝓰 = 𝓷𝓮𝔀 𝓜𝓪𝓹();

		//𝓮𝓿𝓮𝓻𝔂 𝓼𝓽𝓸𝓻𝓮𝓭 𝓻𝓸𝓸𝓶
		𝓯𝓸𝓻 (𝓬𝓸𝓷𝓼𝓽 𝓸𝓫𝓳 𝓸𝓯 𝓻𝓸𝓸𝓶𝓙𝓢𝓞𝓝𝓵𝓲𝓼𝓽) {
			//𝓻𝓮𝓪𝓭 𝓪𝓷𝓭 𝓹𝓪𝓻𝓼𝓮 𝓯𝓲𝓵𝓮
			𝓵𝓮𝓽 𝓻𝓸𝓸𝓶𝓕𝓲𝓵𝓮;

			𝓽𝓻𝔂 {
				𝓻𝓸𝓸𝓶𝓕𝓲𝓵𝓮 = 𝓯𝓼.𝓻𝓮𝓪𝓭𝓕𝓲𝓵𝓮𝓢𝔂𝓷𝓬(`./𝓭𝓫/𝓬𝓸𝓾𝓷𝓽/${𝓸𝓫𝓳}`);
			} 𝓬𝓪𝓽𝓬𝓱 (𝓮) {
				𝓬𝓸𝓷𝓼𝓸𝓵𝓮.𝓵𝓸𝓰(`𝓮𝓻𝓻𝓸𝓻 𝓻𝓮𝓪𝓭𝓲𝓷𝓰 𝓯𝓲𝓵𝓮 ${𝓸𝓫𝓳}, 𝓲𝓽 𝓶𝓪𝔂 𝓫𝓮 𝓪 𝓭𝓲𝓻\𝓷${𝓮}`);
				𝓫𝓻𝓮𝓪𝓴;
			}

			𝓬𝓸𝓷𝓼𝓽 𝓻𝓶 = 𝓙𝓢𝓞𝓝.𝓹𝓪𝓻𝓼𝓮(𝓻𝓸𝓸𝓶𝓕𝓲𝓵𝓮);

			//𝓰𝓮𝓽 𝓻𝓸𝓸𝓶 𝓲𝓭 𝓯𝓻𝓸𝓶 𝓽𝓱𝓮 𝓯𝓲𝓵𝓮 𝓷𝓪𝓶𝓮
			𝓬𝓸𝓷𝓼𝓽 𝓻𝓸𝓸𝓶𝓘𝓓 = 𝓸𝓫𝓳.𝓼𝓾𝓫𝓼𝓽𝓻𝓲𝓷𝓰(0, 𝓸𝓫𝓳.𝓵𝓮𝓷𝓰𝓽𝓱 - 5);

			//𝓬𝓻𝓮𝓪𝓽𝓮 𝓪 𝓼𝓾𝓫𝓶𝓪𝓹 𝓯𝓸𝓻 𝓽𝓱𝓮 𝓻𝓸𝓸𝓶
			𝓬𝓸𝓷𝓼𝓽 𝓻𝓸𝓸𝓶𝓜𝓪𝓹 = 𝓷𝓮𝔀 𝓜𝓪𝓹();
			𝓽𝓱𝓲𝓼.𝓹𝓮𝓻𝓡𝓸𝓸𝓶.𝓼𝓮𝓽(𝓻𝓸𝓸𝓶𝓘𝓓, 𝓻𝓸𝓸𝓶𝓜𝓪𝓹);

			//𝓮𝓪𝓬𝓱 𝔀𝓸𝓻𝓭 𝓲𝓼 𝓪 𝓴𝓮𝔂 𝓽𝓸 𝓪 𝓼𝓮𝓽 𝓸𝓯 𝓼𝓽𝓪𝓽𝓼 𝓹𝓮𝓻 𝓾𝓼𝓮𝓻
			𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭𝓼𝓢𝓪𝓿𝓮𝓭 = 𝓞𝓫𝓳𝓮𝓬𝓽.𝓴𝓮𝔂𝓼(𝓻𝓶);
			𝓯𝓸𝓻 (𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭 𝓸𝓯 𝔀𝓸𝓻𝓭𝓼𝓢𝓪𝓿𝓮𝓭) {
				//𝓰𝓮𝓽 𝓽𝓱𝓮 𝓼𝓮𝓽 𝓸𝓯 𝓼𝓽𝓪𝓽𝓼 𝓯𝓸𝓻 𝓽𝓱𝓪𝓽 𝔀𝓸𝓻𝓭
				𝓬𝓸𝓷𝓼𝓽 𝓼𝓽𝓪𝓽𝓼 = 𝓻𝓶[𝔀𝓸𝓻𝓭];
				𝓬𝓸𝓷𝓼𝓽 𝓾𝓼𝓮𝓻𝓼 = 𝓞𝓫𝓳𝓮𝓬𝓽.𝓴𝓮𝔂𝓼(𝓼𝓽𝓪𝓽𝓼);

				//𝓬𝓻𝓮𝓪𝓽𝓮 𝓪 𝓶𝓪𝓹 𝓯𝓸𝓻 𝓮𝓪𝓬𝓱 𝔀𝓸𝓻𝓭 𝓽𝓸 𝓼𝓽𝓸𝓻𝓮 𝓮𝓪𝓬𝓱 𝓾𝓼𝓮𝓻
				𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭𝓜𝓪𝓹 = 𝓷𝓮𝔀 𝓜𝓪𝓹();
				𝔀𝓸𝓻𝓭𝓜𝓪𝓹.𝓼𝓮𝓽(𝔀𝓸𝓻𝓭, 𝔀𝓸𝓻𝓭𝓜𝓪𝓹);

				//𝓹𝓻𝓸𝓬𝓮𝓼𝓼 𝓮𝓪𝓬𝓱 𝓾𝓼𝓮𝓻
				𝓯𝓸𝓻 (𝓬𝓸𝓷𝓼𝓽 𝓾𝓼𝓮𝓻 𝓸𝓯 𝓾𝓼𝓮𝓻𝓼) {
					//𝓻𝓮𝓶𝓪𝓲𝓷𝓲𝓷𝓰 𝓫𝓲𝓽 𝓽𝓸 𝓹𝓪𝓻𝓬𝓮 𝓼𝓱𝓸𝓾𝓵𝓭 𝓳𝓾𝓼𝓽 𝓫𝓮 𝓪𝓷 𝓲𝓷𝓽 𝓽𝓸 𝓹𝓵𝓸𝓹 𝓲𝓷
					𝓬𝓸𝓷𝓼𝓽 𝓾𝓼𝓮𝓻𝓤𝓼𝓪𝓰𝓮 = 𝓼𝓽𝓪𝓽𝓼[𝓾𝓼𝓮𝓻];

					//𝓲𝓯 𝓷𝓸𝓽 𝓪 𝓷𝓾𝓶𝓫𝓮𝓻 𝓲𝓽𝓼 𝓲𝓷𝓿𝓪𝓵𝓲𝓭 𝓭𝓪𝓽𝓪
					𝓲𝓯 (𝓝𝓾𝓶𝓫𝓮𝓻.𝓲𝓼𝓝𝓪𝓝(𝓾𝓼𝓮𝓻𝓤𝓼𝓪𝓰𝓮)) 𝓻𝓮𝓽𝓾𝓻𝓷;

					𝔀𝓸𝓻𝓭𝓜𝓪𝓹.𝓼𝓮𝓽(𝓾𝓼𝓮𝓻, 𝓾𝓼𝓮𝓻𝓤𝓼𝓪𝓰𝓮);
				}
			}
		}
	}

	𝓪𝓼𝔂𝓷𝓬 𝓪𝓭𝓭𝓣𝓸𝓤𝓼𝓮𝓻(𝓻𝓸𝓸𝓶, 𝔀𝓸𝓻𝓭, 𝓾𝓼𝓮𝓻, 𝓪𝓶𝓸𝓾𝓷𝓽) {
		𝓲𝓯 (!𝓽𝓱𝓲𝓼.𝓹𝓮𝓻𝓡𝓸𝓸𝓶.𝓱𝓪𝓼(𝓻𝓸𝓸𝓶)) 𝓽𝓱𝓲𝓼.𝓹𝓮𝓻𝓡𝓸𝓸𝓶.𝓼𝓮𝓽(𝓻𝓸𝓸𝓶, 𝓷𝓮𝔀 𝓜𝓪𝓹());

		𝓵𝓮𝓽 𝓼𝓽𝓪𝓽𝓼 = 𝓽𝓱𝓲𝓼.𝓹𝓮𝓻𝓡𝓸𝓸𝓶.𝓰𝓮𝓽(𝓻𝓸𝓸𝓶).𝓰𝓮𝓽(𝔀𝓸𝓻𝓭);

		𝓲𝓯 (!𝓼𝓽𝓪𝓽𝓼) {
			𝓼𝓽𝓪𝓽𝓼 = 𝓷𝓮𝔀 𝓜𝓪𝓹();

			𝓽𝓱𝓲𝓼.𝓹𝓮𝓻𝓡𝓸𝓸𝓶.𝓰𝓮𝓽(𝓻𝓸𝓸𝓶).𝓼𝓮𝓽(𝔀𝓸𝓻𝓭, 𝓼𝓽𝓪𝓽𝓼);
		}

		𝓵𝓮𝓽 𝓬𝓾𝓻𝓻𝓮𝓷𝓽 = 𝓼𝓽𝓪𝓽𝓼.𝓰𝓮𝓽(𝓾𝓼𝓮𝓻);

		//𝓲𝓯 𝓾𝓷𝓭𝓮𝓯𝓲𝓷𝓮𝓭 𝓼𝓮𝓽 𝓲𝓽 𝓽𝓸 0 𝓳𝓾𝓼𝓽 𝓽𝓸 𝓶𝓪𝓴𝓮 𝓼𝓾𝓻𝓮 𝓲 𝓭𝓸𝓷𝓽 𝓯𝓸𝓸𝓽𝓰𝓾𝓷 𝓶𝔂𝓼𝓮𝓵𝓯
		𝓲𝓯 (!𝓬𝓾𝓻𝓻𝓮𝓷𝓽) 𝓬𝓾𝓻𝓻𝓮𝓷𝓽 = 0;

		//𝓼𝓮𝓽 𝓷𝓮𝔀 𝓿𝓪𝓵𝓾𝓮
		𝓼𝓽𝓪𝓽𝓼.𝓼𝓮𝓽(𝓾𝓼𝓮𝓻, 𝓬𝓾𝓻𝓻𝓮𝓷𝓽 + 𝓪𝓶𝓸𝓾𝓷𝓽);

		𝓽𝓱𝓲𝓼.𝓺𝓾𝓮𝓾𝓮𝓦𝓻𝓲𝓽𝓮(𝓻𝓸𝓸𝓶);
	}

	𝓪𝓼𝔂𝓷𝓬 𝓺𝓾𝓮𝓾𝓮𝓦𝓻𝓲𝓽𝓮(𝓻𝓸𝓸𝓶) {
		//𝓽𝓱𝓮 𝓭𝓪𝓽𝓪 𝓲𝓼 𝓫𝓮𝓲𝓷𝓰 𝓰𝓵𝓸𝓫𝓪𝓵, 𝓲𝓯 𝓽𝓱𝓮𝓻𝓮𝓼 𝓪 𝓼𝓬𝓱𝓮𝓭𝓾𝓵𝓮𝓭 𝔀𝓻𝓲𝓽𝓮 𝓺𝓾𝓮𝓾𝓮𝓭 𝓪𝓵𝓻𝓮𝓪𝓭𝔂
		//𝓽𝓱𝓮 𝓭𝓪𝓽𝓪 𝔀𝓲𝓵𝓵 𝓫𝓮 𝔀𝓻𝓲𝓽𝓽𝓮𝓷 𝓪𝓵𝓻𝓮𝓪𝓭𝔂 𝓼𝓸 𝔀𝓮 𝓬𝓪𝓷 𝓳𝓾𝓼𝓽 𝓽𝓸𝓼𝓼 𝓪𝓷𝔂 𝓸𝓽𝓱𝓮𝓻 𝓺𝓾𝓮𝓾𝓮𝓭
		//𝓯𝓸𝓻 𝓽𝓱𝓪𝓽 𝓻𝓸𝓸𝓶
		𝓲𝓯 (𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮𝓠𝓾𝓮𝓾𝓮𝓭.𝓰𝓮𝓽(𝓻𝓸𝓸𝓶)) 𝓻𝓮𝓽𝓾𝓻𝓷;

		//𝓰𝓮𝓽 𝓽𝓱𝓮 𝓵𝓪𝓼𝓽 𝔀𝓻𝓲𝓽𝓮 𝓽𝓸 𝓪𝔀𝓪𝓲𝓽
		𝓬𝓸𝓷𝓼𝓽 𝓬𝓾𝓻𝓻𝓮𝓷𝓽𝓦𝓻𝓲𝓽𝓮𝓟𝓻𝓸𝓶𝓲𝓼𝓮 = 𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮𝓟𝓻𝓸𝓶𝓲𝓼𝓮.𝓰𝓮𝓽(𝓻𝓸𝓸𝓶);

		𝓲𝓯 (𝓬𝓾𝓻𝓻𝓮𝓷𝓽𝓦𝓻𝓲𝓽𝓮𝓟𝓻𝓸𝓶𝓲𝓼𝓮) {
			//𝓼𝓪𝔂 𝔀𝓮 𝓪𝓵𝓻𝓮𝓪𝓭𝔂 𝓱𝓪𝓿𝓮 𝓸𝓷𝓮 𝓻𝓲𝓰𝓱𝓽 𝓪𝓯𝓽𝓮𝓻 𝓽𝓱𝓲𝓼
			𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮𝓠𝓾𝓮𝓾𝓮𝓭.𝓼𝓮𝓽(𝓻𝓸𝓸𝓶, 𝓽𝓻𝓾𝓮);

			//𝓹𝓻𝓮𝓿𝓮𝓷𝓽 𝓻𝓪𝓬𝓮𝔂 𝔀𝓻𝓲𝓽𝓮𝓼
			𝓪𝔀𝓪𝓲𝓽 𝓬𝓾𝓻𝓻𝓮𝓷𝓽𝓦𝓻𝓲𝓽𝓮𝓟𝓻𝓸𝓶𝓲𝓼𝓮;
		}

		//𝓼𝓪𝓿𝓮 𝓽𝓱𝓮 𝓹𝓻𝓸𝓶𝓲𝓼𝓮 𝓽𝓸 𝓹𝓻𝓮𝓿𝓮𝓷𝓽 𝓻𝓪𝓬𝓮𝔂 𝔀𝓻𝓲𝓽𝓮𝓼
		𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮𝓟𝓻𝓸𝓶𝓲𝓼𝓮.𝓼𝓮𝓽(𝓻𝓸𝓸𝓶, 𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮(𝓻𝓸𝓸𝓶));

		//𝓷𝓸 𝓵𝓸𝓷𝓰𝓮𝓻 𝓺𝓾𝓮𝓾𝓮𝓲𝓷𝓰
		𝓽𝓱𝓲𝓼.𝔀𝓻𝓲𝓽𝓮𝓠𝓾𝓮𝓾𝓮𝓭.𝓭𝓮𝓵𝓮𝓽𝓮(𝓻𝓸𝓸𝓶);
	}

	𝓪𝓼𝔂𝓷𝓬 𝔀𝓻𝓲𝓽𝓮(𝓻𝓸𝓸𝓶) {
		𝓬𝓸𝓷𝓼𝓽 𝓼𝓽𝓪𝓽𝓼𝓜𝓪𝓹 = 𝓽𝓱𝓲𝓼.𝓹𝓮𝓻𝓡𝓸𝓸𝓶.𝓰𝓮𝓽(𝓻𝓸𝓸𝓶);

		𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭𝓼 = 𝓐𝓻𝓻𝓪𝔂.𝓯𝓻𝓸𝓶(𝓼𝓽𝓪𝓽𝓼𝓜𝓪𝓹.𝓴𝓮𝔂𝓼());

		𝓬𝓸𝓷𝓼𝓽 𝓼𝓽𝓪𝓽𝓼𝓞𝓫𝓳𝓜𝓪𝓹 = 𝓷𝓮𝔀 𝓜𝓪𝓹();

		𝓯𝓸𝓻 (𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭 𝓸𝓯 𝔀𝓸𝓻𝓭𝓼) {
			𝓼𝓽𝓪𝓽𝓼𝓞𝓫𝓳𝓜𝓪𝓹.𝓼𝓮𝓽(𝔀𝓸𝓻𝓭, 𝓞𝓫𝓳𝓮𝓬𝓽.𝓯𝓻𝓸𝓶𝓔𝓷𝓽𝓻𝓲𝓮𝓼(𝓼𝓽𝓪𝓽𝓼𝓜𝓪𝓹.𝓰𝓮𝓽(𝔀𝓸𝓻𝓭).𝓮𝓷𝓽𝓻𝓲𝓮𝓼()));
		}

		𝓬𝓸𝓷𝓼𝓽 𝓼𝓽𝓪𝓽𝓼𝓞𝓫𝓳 = 𝓞𝓫𝓳𝓮𝓬𝓽.𝓯𝓻𝓸𝓶𝓔𝓷𝓽𝓻𝓲𝓮𝓼(𝓼𝓽𝓪𝓽𝓼𝓞𝓫𝓳𝓜𝓪𝓹.𝓮𝓷𝓽𝓻𝓲𝓮𝓼());

		𝓬𝓸𝓷𝓼𝓽 𝓼𝓽𝓪𝓽𝓼𝓢𝓽𝓻𝓲𝓷𝓰 = 𝓙𝓢𝓞𝓝.𝓼𝓽𝓻𝓲𝓷𝓰𝓲𝓯𝔂(𝓼𝓽𝓪𝓽𝓼𝓞𝓫𝓳, 𝓷𝓾𝓵𝓵, 2);

		𝓬𝓸𝓷𝓼𝓽 𝓸𝓵𝓭𝓢𝓽𝓪𝓽𝓼𝓢𝓽𝓻𝓲𝓷𝓰 = 𝓽𝓱𝓲𝓼.𝓼𝓽𝓪𝓽𝓼𝓢𝓽𝓻𝓲𝓷𝓰.𝓰𝓮𝓽(𝓻𝓸𝓸𝓶);

		//𝓲𝓯 𝓲𝓽𝓼 𝓽𝓱𝓮 𝓼𝓪𝓶𝓮 𝓪𝓼 𝔀𝓱𝓪𝓽 𝔀𝓪𝓼 𝓪𝓵𝓻𝓮𝓪𝓭𝔂 𝔀𝓻𝓲𝓽𝓽𝓮𝓷 𝓷𝓸 𝓷𝓮𝓮𝓭 𝓽𝓸 𝔀𝓻𝓲𝓽𝓮
		𝓲𝓯 (𝓸𝓵𝓭𝓢𝓽𝓪𝓽𝓼𝓢𝓽𝓻𝓲𝓷𝓰 === 𝓼𝓽𝓪𝓽𝓼𝓢𝓽𝓻𝓲𝓷𝓰) 𝓻𝓮𝓽𝓾𝓻𝓷;

		𝓽𝓻𝔂 {
			𝓯𝓼.𝔀𝓻𝓲𝓽𝓮𝓕𝓲𝓵𝓮𝓢𝔂𝓷𝓬(`./𝓭𝓫/𝓬𝓸𝓾𝓷𝓽/${𝓻𝓸𝓸𝓶}.𝓳𝓼𝓸𝓷`, 𝓼𝓽𝓪𝓽𝓼𝓢𝓽𝓻𝓲𝓷𝓰);
		} 𝓬𝓪𝓽𝓬𝓱 (𝓮) {
			𝓬𝓸𝓷𝓼𝓸𝓵𝓮.𝓵𝓸𝓰(`𝓮𝓻𝓻𝓸𝓻 𝔀𝓻𝓲𝓽𝓲𝓷𝓰 𝓯𝓲𝓵𝓮 𝓯𝓸𝓻 ${𝓻𝓸𝓸𝓶}\𝓷${𝓮}`);
		}
	}
}

𝓮𝔁𝓹𝓸𝓻𝓽 { 𝓦𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽 };