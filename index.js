//𝓘𝓶𝓹𝓸𝓻𝓽 𝓭𝓮𝓹𝓮𝓷𝓭𝓮𝓷𝓬𝓲𝓮𝓼
𝓲𝓶𝓹𝓸𝓻𝓽 {
	𝓐𝓾𝓽𝓸𝓳𝓸𝓲𝓷𝓡𝓸𝓸𝓶𝓼𝓜𝓲𝔁𝓲𝓷,
	𝓜𝓪𝓽𝓻𝓲𝔁𝓒𝓵𝓲𝓮𝓷𝓽,
	𝓢𝓲𝓶𝓹𝓵𝓮𝓕𝓼𝓢𝓽𝓸𝓻𝓪𝓰𝓮𝓟𝓻𝓸𝓿𝓲𝓭𝓮𝓻,
	𝓡𝓲𝓬𝓱𝓡𝓮𝓹𝓵𝓲𝓮𝓼𝓟𝓻𝓮𝓹𝓻𝓸𝓬𝓮𝓼𝓼𝓸𝓻
} 𝓯𝓻𝓸𝓶 "𝓶𝓪𝓽𝓻𝓲𝔁-𝓫𝓸𝓽-𝓼𝓭𝓴";
𝓲𝓶𝓹𝓸𝓻𝓽 { 𝓻𝓮𝓪𝓭𝓕𝓲𝓵𝓮𝓢𝔂𝓷𝓬 } 𝓯𝓻𝓸𝓶 "𝓷𝓸𝓭𝓮:𝓯𝓼";
𝓲𝓶𝓹𝓸𝓻𝓽 { 𝓹𝓪𝓻𝓼𝓮 } 𝓯𝓻𝓸𝓶 "𝔂𝓪𝓶𝓵";
𝓲𝓶𝓹𝓸𝓻𝓽 { 𝓦𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽 } 𝓯𝓻𝓸𝓶 "./𝔀𝓸𝓻𝓭-𝓬𝓸𝓾𝓷𝓽𝓲𝓷𝓰.𝓳𝓼";

//𝓟𝓪𝓻𝓼𝓮 𝓨𝓐𝓜𝓛 𝓬𝓸𝓷𝓯𝓲𝓰𝓾𝓻𝓪𝓽𝓲𝓸𝓷 𝓯𝓲𝓵𝓮
𝓬𝓸𝓷𝓼𝓽 𝓵𝓸𝓰𝓲𝓷𝓕𝓲𝓵𝓮 = 𝓻𝓮𝓪𝓭𝓕𝓲𝓵𝓮𝓢𝔂𝓷𝓬("./𝓭𝓫/𝓵𝓸𝓰𝓲𝓷.𝔂𝓪𝓶𝓵", "𝓾𝓽𝓯8");
𝓬𝓸𝓷𝓼𝓽 𝓵𝓸𝓰𝓲𝓷𝓟𝓪𝓻𝓼𝓮𝓭 = 𝓹𝓪𝓻𝓼𝓮(𝓵𝓸𝓰𝓲𝓷𝓕𝓲𝓵𝓮);
𝓬𝓸𝓷𝓼𝓽 𝓱𝓸𝓶𝓮𝓼𝓮𝓻𝓿𝓮𝓻 = 𝓵𝓸𝓰𝓲𝓷𝓟𝓪𝓻𝓼𝓮𝓭["𝓱𝓸𝓶𝓮𝓼𝓮𝓻𝓿𝓮𝓻-𝓾𝓻𝓵"];
𝓬𝓸𝓷𝓼𝓽 𝓪𝓬𝓬𝓮𝓼𝓼𝓣𝓸𝓴𝓮𝓷 = 𝓵𝓸𝓰𝓲𝓷𝓟𝓪𝓻𝓼𝓮𝓭["𝓵𝓸𝓰𝓲𝓷-𝓽𝓸𝓴𝓮𝓷"];

//𝓹𝓻𝓮𝓯𝓲𝔁
𝓬𝓸𝓷𝓼𝓽 𝓹𝓻𝓮𝓯𝓲𝔁 = ".";

//𝓽𝓱𝓮 𝓫𝓸𝓽 𝓼𝔂𝓷𝓬 𝓼𝓸𝓶𝓮𝓽𝓱𝓲𝓷𝓰 𝓲𝓭𝓴 𝓫𝓻𝓸 𝓲𝓽 𝔀𝓪𝓼 𝓱𝓮𝓻𝓮 𝓲𝓷 𝓽𝓱𝓮 𝓮𝔁𝓪𝓶𝓹𝓵𝓮 𝓼𝓸 𝓲 𝓭𝓸𝓷𝓽 𝓽𝓸𝓾𝓬𝓱 𝓲𝓽 ;-;
𝓬𝓸𝓷𝓼𝓽 𝓼𝓽𝓸𝓻𝓪𝓰𝓮 = 𝓷𝓮𝔀 𝓢𝓲𝓶𝓹𝓵𝓮𝓕𝓼𝓢𝓽𝓸𝓻𝓪𝓰𝓮𝓟𝓻𝓸𝓿𝓲𝓭𝓮𝓻("𝓫𝓸𝓽.𝓳𝓼𝓸𝓷");

//𝓵𝓸𝓰𝓲𝓷 𝓽𝓸 𝓬𝓵𝓲𝓮𝓷𝓽
𝓬𝓸𝓷𝓼𝓽 𝓬𝓵𝓲𝓮𝓷𝓽 = 𝓷𝓮𝔀 𝓜𝓪𝓽𝓻𝓲𝔁𝓒𝓵𝓲𝓮𝓷𝓽(𝓱𝓸𝓶𝓮𝓼𝓮𝓻𝓿𝓮𝓻, 𝓪𝓬𝓬𝓮𝓼𝓼𝓣𝓸𝓴𝓮𝓷, 𝓼𝓽𝓸𝓻𝓪𝓰𝓮);
// 𝓐𝓾𝓽𝓸𝓳𝓸𝓲𝓷𝓡𝓸𝓸𝓶𝓼𝓜𝓲𝔁𝓲𝓷.𝓼𝓮𝓽𝓾𝓹𝓞𝓷𝓒𝓵𝓲𝓮𝓷𝓽(𝓬𝓵𝓲𝓮𝓷𝓽);

//𝓭𝓸 𝓷𝓸𝓽 𝓲𝓷𝓬𝓵𝓾𝓭𝓮 𝓻𝓮𝓹𝓵𝓲𝓮𝓭 𝓶𝓮𝓼𝓼𝓪𝓰𝓮 𝓲𝓷 𝓶𝓮𝓼𝓼𝓪𝓰𝓮
𝓬𝓵𝓲𝓮𝓷𝓽.𝓪𝓭𝓭𝓟𝓻𝓮𝓹𝓻𝓸𝓬𝓮𝓼𝓼𝓸𝓻(𝓷𝓮𝔀 𝓡𝓲𝓬𝓱𝓡𝓮𝓹𝓵𝓲𝓮𝓼𝓟𝓻𝓮𝓹𝓻𝓸𝓬𝓮𝓼𝓼𝓸𝓻(𝓯𝓪𝓵𝓼𝓮));

𝓬𝓸𝓷𝓼𝓽 𝓬𝓸𝓾𝓷𝓽𝓮𝓻 = 𝓷𝓮𝔀 𝓦𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽();

//𝓹𝓻𝓮𝓪𝓵𝓵𝓸𝓬𝓪𝓽𝓮 𝓿𝓪𝓻𝓲𝓪𝓫𝓵𝓮𝓼 𝓼𝓸 𝓽𝓱𝓮𝔂 𝓱𝓪𝓿𝓮 𝓪 𝓰𝓵𝓸𝓫𝓪𝓵 𝓼𝓬𝓸𝓹𝓮
𝓵𝓮𝓽 𝓶𝔁𝓲𝓭;

𝓬𝓸𝓷𝓼𝓽 𝓯𝓲𝓵𝓽𝓮𝓻 = {
	//𝓭𝓸𝓷𝓽 𝓮𝔁𝓹𝓮𝓬𝓽 𝓪𝓷𝔂 𝓹𝓻𝓮𝓼𝓮𝓷𝓬𝓮 𝓯𝓻𝓸𝓶 𝓶.𝓸𝓻𝓰, 𝓫𝓾𝓽 𝓲𝓷 𝓽𝓱𝓮 𝓬𝓪𝓼𝓮 𝓹𝓻𝓮𝓼𝓮𝓷𝓬𝓮 𝓼𝓱𝓸𝔀𝓼 𝓾𝓹 𝓲𝓽𝓼 𝓲𝓻𝓻𝓮𝓵𝓮𝓿𝓪𝓷𝓽 𝓽𝓸 𝓽𝓱𝓲𝓼 𝓫𝓸𝓽
	𝓹𝓻𝓮𝓼𝓮𝓷𝓬𝓮: { 𝓼𝓮𝓷𝓭𝓮𝓻𝓼: [] },
	𝓻𝓸𝓸𝓶: {
		//𝓮𝓹𝓱𝓮𝓶𝓮𝓻𝓪𝓵 𝓮𝓿𝓮𝓷𝓽𝓼 𝓪𝓻𝓮 𝓷𝓮𝓿𝓮𝓻 𝓾𝓼𝓮𝓭 𝓲𝓷 𝓽𝓱𝓲𝓼 𝓫𝓸𝓽, 𝓪𝓻𝓮 𝓶𝓸𝓼𝓽𝓵𝔂 𝓲𝓷𝓬𝓸𝓷𝓼𝓮𝓺𝓾𝓮𝓷𝓽𝓪𝓲𝓵 𝓪𝓷𝓭 𝓲𝓻𝓻𝓮𝓵𝓮𝓿𝓪𝓷𝓽
		𝓮𝓹𝓱𝓮𝓶𝓮𝓻𝓪𝓵: { 𝓼𝓮𝓷𝓭𝓮𝓻𝓼: [] },
		//𝔀𝓮 𝓯𝓮𝓽𝓬𝓱 𝓼𝓽𝓪𝓽𝓮 𝓶𝓪𝓷𝓾𝓪𝓵𝓵𝔂 𝓵𝓪𝓽𝓮𝓻, 𝓱𝓸𝓹𝓮𝓯𝓾𝓵𝓵𝔂 𝔀𝓲𝓽𝓱 𝓫𝓮𝓽𝓽𝓮𝓻 𝓵𝓸𝓪𝓭 𝓫𝓪𝓵𝓪𝓷𝓬𝓲𝓷𝓰
		𝓼𝓽𝓪𝓽𝓮: {
			𝓼𝓮𝓷𝓭𝓮𝓻𝓼: [],
			𝓽𝔂𝓹𝓮𝓼: [],
			𝓵𝓪𝔃𝔂_𝓵𝓸𝓪𝓭_𝓶𝓮𝓶𝓫𝓮𝓻𝓼: 𝓽𝓻𝓾𝓮,
		},
		//𝔀𝓮 𝔀𝓲𝓵𝓵 𝓶𝓪𝓷𝓾𝓪𝓵𝓵𝔂 𝓯𝓮𝓽𝓬𝓱 𝓮𝓿𝓮𝓷𝓽𝓼 𝓪𝓷𝔂𝔀𝓪𝔂𝓼, 𝓽𝓱𝓲𝓼 𝓲𝓼 𝓳𝓾𝓼𝓽 𝓵𝓲𝓶𝓲𝓽𝓲𝓷𝓰 𝓱𝓸𝔀 𝓶𝓾𝓬𝓱 𝓫𝓪𝓬𝓴𝓯𝓲𝓵𝓵 𝓫𝓸𝓽 𝓰𝓮𝓽𝓼 𝓪𝓼 𝓽𝓸 𝓷𝓸𝓽
		//𝓻𝓮𝓼𝓹𝓸𝓷𝓭 𝓽𝓸 𝓮𝓿𝓮𝓷𝓽𝓼 𝓯𝓪𝓻 𝓸𝓾𝓽 𝓸𝓯 𝓿𝓲𝓮𝔀
		𝓽𝓲𝓶𝓮𝓵𝓲𝓷𝓮: {
			𝓵𝓲𝓶𝓲𝓽: 10000,
		},
	},
};

//𝓢𝓽𝓪𝓻𝓽 𝓒𝓵𝓲𝓮𝓷𝓽
𝓬𝓵𝓲𝓮𝓷𝓽.𝓼𝓽𝓪𝓻𝓽(𝓯𝓲𝓵𝓽𝓮𝓻).𝓽𝓱𝓮𝓷(𝓪𝓼𝔂𝓷𝓬 (𝓯𝓲𝓵𝓽𝓮𝓻) =&gt; {
	𝓬𝓸𝓷𝓼𝓸𝓵𝓮.𝓵𝓸𝓰("𝓒𝓵𝓲𝓮𝓷𝓽 𝓼𝓽𝓪𝓻𝓽𝓮𝓭!");

	//𝓰𝓮𝓽 𝓶𝔁𝓲𝓭
	// 𝓶𝔁𝓲𝓭 = 𝓪𝔀𝓪𝓲𝓽 𝓬𝓵𝓲𝓮𝓷𝓽.𝓰𝓮𝓽𝓤𝓼𝓮𝓻𝓘𝓭().𝓬𝓪𝓽𝓬𝓱(() =&gt; {});
});

//𝔀𝓱𝓮𝓷 𝓽𝓱𝓮 𝓬𝓵𝓲𝓮𝓷𝓽 𝓻𝓮𝓬𝓲𝓮𝓿𝓮𝓼 𝓪𝓷 𝓮𝓿𝓮𝓷𝓽
𝓬𝓵𝓲𝓮𝓷𝓽.𝓸𝓷("𝓻𝓸𝓸𝓶.𝓮𝓿𝓮𝓷𝓽", 𝓪𝓼𝔂𝓷𝓬 (𝓻𝓸𝓸𝓶𝓘𝓭, 𝓮𝓿𝓮𝓷𝓽) =&gt; {
	//𝓲𝓰𝓷𝓸𝓻𝓮 𝓮𝓿𝓮𝓷𝓽𝓼 𝓼𝓮𝓷𝓽 𝓫𝔂 𝓼𝓮𝓵𝓯, 𝓾𝓷𝓵𝓮𝓼𝓼 𝓲𝓽𝓼 𝓪 𝓫𝓪𝓷𝓵𝓲𝓼𝓽 𝓹𝓸𝓵𝓲𝓬𝔂 𝓾𝓹𝓭𝓪𝓽𝓮
	𝓲𝓯 (𝓮𝓿𝓮𝓷𝓽.𝓼𝓮𝓷𝓭𝓮𝓻 === 𝓶𝔁𝓲𝓭) {
		𝓻𝓮𝓽𝓾𝓻𝓷;
	}

	//𝔀𝓮 𝓳𝓾𝓼𝓽 𝔀𝓪𝓷𝓽 𝓻𝓪𝔀 𝓽𝓮𝔁𝓽 𝓽𝓫𝓱
	𝓲𝓯 (!𝓮𝓿𝓮𝓷𝓽?.𝓬𝓸𝓷𝓽𝓮𝓷𝓽?.𝓫𝓸𝓭𝔂) 𝓻𝓮𝓽𝓾𝓻𝓷;

	𝓬𝓸𝓷𝓼𝓽 𝓫𝓸𝓭𝔂 = 𝓮𝓿𝓮𝓷𝓽.𝓬𝓸𝓷𝓽𝓮𝓷𝓽.𝓫𝓸𝓭𝔂.𝓽𝓸𝓛𝓸𝔀𝓮𝓻𝓒𝓪𝓼𝓮();

	𝓲𝓯 (𝓫𝓸𝓭𝔂.𝓼𝓽𝓪𝓻𝓽𝓼𝓦𝓲𝓽𝓱(`${𝓹𝓻𝓮𝓯𝓲𝔁}𝓬𝓸𝓾𝓷𝓽`)) {
		//𝓰𝓮𝓽 𝔀𝓸𝓻𝓭 𝓹𝓪𝓻𝓪𝓶
		𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭 = 𝓫𝓸𝓭𝔂.𝓼𝓹𝓵𝓲𝓽(" ")[1];

		//𝓰𝓮𝓽 𝓼𝓽𝓪𝓽𝓼 𝓶𝓪𝓹
		𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭𝓼𝓽𝓪𝓽𝓼 = 𝓬𝓸𝓾𝓷𝓽𝓮𝓻.𝓹𝓮𝓻𝓡𝓸𝓸𝓶.𝓰𝓮𝓽(𝓻𝓸𝓸𝓶𝓘𝓭)?.𝓰𝓮𝓽(𝔀𝓸𝓻𝓭);

		//𝓲𝓯 𝓷𝓸 𝓼𝓽𝓪𝓽𝓼
		𝓲𝓯 (!𝔀𝓸𝓻𝓭𝓼𝓽𝓪𝓽𝓼) {
			𝓬𝓵𝓲𝓮𝓷𝓽.𝓻𝓮𝓹𝓵𝔂𝓝𝓸𝓽𝓲𝓬𝓮(𝓻𝓸𝓸𝓶𝓘𝓭, 𝓮𝓿𝓮𝓷𝓽, "❌ | 𝓣𝓱𝓪𝓽 𝔀𝓸𝓻𝓭 𝓱𝓪𝓼 𝓷𝓸𝓽 𝓫𝓮𝓮𝓷 𝓾𝓼𝓮𝓭");

			𝓻𝓮𝓽𝓾𝓻𝓷;
		}

		//𝓰𝓮𝓽 𝓪𝓵𝓵 𝓾𝓼𝓮𝓻𝓼
		𝓬𝓸𝓷𝓼𝓽 𝓾𝓼𝓮𝓻𝓼 = 𝓐𝓻𝓻𝓪𝔂.𝓯𝓻𝓸𝓶(𝔀𝓸𝓻𝓭𝓼𝓽𝓪𝓽𝓼.𝓴𝓮𝔂𝓼());

		//𝓰𝓮𝓷𝓮𝓻𝓪𝓽𝓮 𝓱𝓾𝓶𝓪𝓷 𝓻𝓮𝓪𝓭𝓪𝓫𝓵𝓮 𝓼𝓽𝓻𝓲𝓷𝓰
		𝓵𝓮𝓽 𝓶𝓼𝓰 = "";
		𝓯𝓸𝓻 (𝓬𝓸𝓷𝓼𝓽 𝓾𝓼𝓮𝓻 𝓸𝓯 𝓾𝓼𝓮𝓻𝓼) {
			𝓶𝓼𝓰 += `&lt;𝓫&gt;${𝓾𝓼𝓮𝓻}<!--𝓫-->: ${𝔀𝓸𝓻𝓭𝓼𝓽𝓪𝓽𝓼.𝓰𝓮𝓽(𝓾𝓼𝓮𝓻)}&lt;𝓫𝓻&gt;`;
		}

		𝓬𝓵𝓲𝓮𝓷𝓽.𝓻𝓮𝓹𝓵𝔂𝓗𝓽𝓶𝓵𝓝𝓸𝓽𝓲𝓬𝓮(𝓻𝓸𝓸𝓶𝓘𝓭, 𝓮𝓿𝓮𝓷𝓽, 𝓶𝓼𝓰);
	} 𝓮𝓵𝓼𝓮 {
		𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭𝓼 = 𝓫𝓸𝓭𝔂.𝓼𝓹𝓵𝓲𝓽(/[^𝓪-𝔃0-9]/𝓰𝓲);

		𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼 = 𝓷𝓮𝔀 𝓜𝓪𝓹();

		𝓯𝓸𝓻 (𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭 𝓸𝓯 𝔀𝓸𝓻𝓭𝓼) {
			// 𝓘𝓯 𝓽𝓱𝓮 𝔀𝓸𝓻𝓭 𝓪𝓵𝓻𝓮𝓪𝓭𝔂 𝓮𝔁𝓲𝓼𝓽𝓼 𝓲𝓷 𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼, 𝓲𝓷𝓬𝓻𝓮𝓶𝓮𝓷𝓽 𝓲𝓽𝓼 𝓬𝓸𝓾𝓷𝓽
			𝓲𝓯 (𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼.𝓱𝓪𝓼(𝔀𝓸𝓻𝓭)) {
				𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼.𝓼𝓮𝓽(𝔀𝓸𝓻𝓭, 𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼.𝓰𝓮𝓽(𝔀𝓸𝓻𝓭) + 1);
			} 𝓮𝓵𝓼𝓮 {
				// 𝓘𝓯 𝓽𝓱𝓮 𝔀𝓸𝓻𝓭 𝓭𝓸𝓮𝓼𝓷'𝓽 𝓮𝔁𝓲𝓼𝓽, 𝓲𝓷𝓲𝓽𝓲𝓪𝓵𝓲𝔃𝓮 𝓲𝓽𝓼 𝓬𝓸𝓾𝓷𝓽 𝓽𝓸 1
				𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼.𝓼𝓮𝓽(𝔀𝓸𝓻𝓭, 1);
			}
		}

		//𝓪𝓭𝓭 𝓮𝓪𝓬𝓱 𝓬𝓸𝓾𝓷𝓽 𝓽𝓸 𝓽𝓱𝓮 𝓾𝓼𝓮𝓻
		𝓬𝓸𝓷𝓼𝓽 𝓬𝓸𝓾𝓷𝓽𝓮𝓭𝓦𝓸𝓻𝓭𝓼 = 𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼.𝓴𝓮𝔂𝓼();
		𝓯𝓸𝓻 (𝓬𝓸𝓷𝓼𝓽 𝔀𝓸𝓻𝓭 𝓸𝓯 𝓬𝓸𝓾𝓷𝓽𝓮𝓭𝓦𝓸𝓻𝓭𝓼) {
			𝓬𝓸𝓾𝓷𝓽𝓮𝓻.𝓪𝓭𝓭𝓣𝓸𝓤𝓼𝓮𝓻(𝓻𝓸𝓸𝓶𝓘𝓭, 𝔀𝓸𝓻𝓭, 𝓮𝓿𝓮𝓷𝓽.𝓼𝓮𝓷𝓭𝓮𝓻, 𝔀𝓸𝓻𝓭𝓒𝓸𝓾𝓷𝓽𝓼.𝓰𝓮𝓽(𝔀𝓸𝓻𝓭));
		}
	}
});